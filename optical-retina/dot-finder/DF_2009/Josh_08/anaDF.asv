function[]=dotFinder(TPN,DPN) %#ok<INUSL>
% 
% TPN = GetMyDir;
% DPN=[TPN 'I\'] %use when running as stand alone script
%% Dot Finder 
%F3 has been modified to handle 8bit single tiff stacks
%large files will be broken into smaller blocks and then recombined

%% Get file names
tic

%Get directory name
f=find(DPN=='\');
f2=f(size(f,2)-1);
f3=f(size(f,2)-2);
TPN=DPN(1:f2); %Define target folder (one level up from files)
if isdir('./history')==0, mkdir('./history'); end %create directory to store steps
save(['./history' TPN(f3:f2-1)],'TPN') %record path in history folder

colormap gray(255) %standard grey colormap
if isdir([TPN 'temp'])==0, mkdir([TPN 'temp']); end %create directory to store steps
if isdir([TPN 'data'])==0, mkdir([TPN 'data']); end %create directory to store steps
if isdir([TPN 'pics'])==0, mkdir([TPN 'pics']); end %create directory to store steps
 


%% Enter Variables
%%Image Variables
% xyum=.103;
% zum=.3;
% % aspect=zum/xyum;% ratio of z to xy dimentions
% channels=3;

%%Dot criteria
step=2; %Sensitivity=grey value step of iterative threshold (2 was standard)
MaxDot=7^3;  %Maximum Dot Volume (in pixels)= maximum dot size for iterative threshold (6^3 was standard)
MinDot=3;  %Minimum Dot Volume (in pixels)= minimum dot size for iterative threshold   (10 was standard)
% PunctaThreshold=1; %Minimum Number of Steps Passed = centroids less than puncta threshold are zeroed. 
% EdgeOfPeak=.5; %Determine Dot Edge = ratio of edge brightness to peak brightness (.5 was standard)
% minFilledVolume=3; %minimum number of pixels in final object contour (20 was standard)
% RoundThreshold=50; %minimum roundness threshold (60 was standard)


%% READ IMAGE
%%Find Images
d=dir(DPN); d=d(3:size(d,1)); %get number of files in directory
Rzs = size(d,1); %find number of planes
clear I
I(:,:,:)=imread([DPN d(1).name]);
[Rys,Rxs,dummy]=size(I);   %#ok<NASGU> %Read first pic 
IgRaw=zeros(Rys,Rxs,Rzs,'uint8');

%%Figure out channels
if size(I,3)==1, 
    channels=1; %if only one channel
elseif size(I,3)==2
    channels=1; %if only two channels
elseif sum(sum(I(:,:,3)))==0
    channels=1; %if third channel is blank
else
    channels=1; %if third channel is not blank
end

for i=1:Rzs
    I(:,:,:)=imread([DPN d(i).name]);
    IgRaw(:,:,i)=uint8(I(:,:,channels)); %ColorSeperate
end
clear I
save([TPN 'temp\IgRaw.mat'],'IgRaw')
image(max(IgRaw,[],3)),pause(.01)

%% Find Image Stats
if ~exist('IgRaw','var') %load green
    load([TPN 'temp/IgRaw.mat']);
end 
IgStat = sort(IgRaw(:));
Gmode = IgStat(round(0.95*Rxs*Rys*Rzs));
clear IgStat


%% Run Blocks

%%Subsample Green Channel
if ~exist('IgRaw','var')%load green if necessary
    load([TPN 'temp/IgRaw.mat'])
end 
Ig = single(IgRaw); 
clear IgRaw 
[ys,xs,zs]=size(Ig);

%% Median filter 
Igm=zeros(ys,xs,zs,'single');
for i=1:zs        
    Igm(:,:,i)=medfilt2(Ig(:,:,i),[3,3]); 
end
clear Ig


%% FIND DOTS Green Channel%%
peakMap = zeros(ys,xs,zs,'uint8');  %set up matrix to map peaks
thresholdMap = zeros(ys,xs,zs,'uint8');   %set up matrix to sum passed thresholds
% indVect = 1:ys*xs*zs;
maxIntensity = uint8(max(Igm(:)));

for i = maxIntensity:-1:Gmode
    %run thresholds through all relevant intensities
    clear Igl labels
    [Igl,labels] = bwlabeln(Igm>i,6);%label each area to check

    %reduce bitdepth if possible
    if labels<65536
        Igl=uint16(Igl);
    end
    if labels <= 1
        labels =2;
    end
    nPixel = hist(Igl(Igl>0), 1:labels);
    %run all lables
    for p=1:labels
        % Morphology Filter, Puncta size criteria
        pixelIndex = find(Igl==p);
        if nPixel(p) < MaxDot && nPixel(p) > MinDot
            %identify peak in labeled object
            if sum(peakMap(pixelIndex))== 0
                peakValue = max(Igm(pixelIndex));
                peakIndex = find(Igl==p & Igm==peakValue);
                if numel(peakIndex) > 1
                    peakIndex = peakIndex(round(numel(peakIndex)/2)); %?
                end
                [y,x,z] = ind2sub([ys xs zs], peakIndex);
                %Register in peak map
                peakMap(y,x,z) = 1;
            end
        else
            Igl(pixelIndex)=0;
        end
    end
    %%Add all passing labeled objects to thresholdMap
    thresholdMap(Igl>0)=thresholdMap(Igl>0)+1;
end 
disp('iterative threshold done')
clear Igl peakIndex


%% FIND DOT CONTOUR AND DIVIDE IF MULTIPLE PEAKS WITHIN
[thresholdLabel nLabels] = bwlabeln(thresholdMap, 6);

if nLabels<65536 %reduce bit depth if possible
    thresholdLabel = uint16(thresholdLabel);
end

for i = 1:nLabels
    peakIndex = find(thresholdLabel==i & peakMap>0);
    thresholdPeak = thresholdMap(peakIndex);
    nPeaks = numel(peakIndex);
    [yPeak xPeak zPeak] = ind2sub([ys xs zs], peakIndex);
    if nPeaks == 1
             cutOff = 0.5 * thresholdPeak;
            contourIndex = find(thresholdLabel==i & thresholdMap>=cutOff);
            [yContour xContour zContour] = ind2sub([ys xs zs],contourIndex);
            if ~exist('Dots','var')
                lastEntry = 0;
            else
                [lastEntry dummy] = size(Dots.Pos);  %#ok<NASGU>
            end
            next = lastEntry+1;
            Dots.Pos(next,:) = [yPeak, xPeak,...
                zPeak];
            Dots.Vox(next).Pos = [yContour,...
                xContour, zContour];
            Dots.Vox(next).Ind = sub2ind([Rys Rxs Rzs],...
                Dots.Vox(next).Pos(:,1), Dots.Vox(next).Pos(:,2),...
                Dots.Vox(next).Pos(:,3));
            Dots.Vol(next) = numel(contourIndex);
            Dots.ITMax(next) = thresholdPeak;
            Dots.ItSum(next) = sum(thresholdMap(contourIndex));
            Dots.Vox(next).RawBright = Igm(contourIndex);
            Dots.MeanBright(next) = mean(Igm(contourIndex));
                                
    else
        thresholdPeak = min(thresholdPeak);
        cutOff = 0.5 * thresholdPeak;
        contourIndex = find(thresholdLabel==i & thresholdMap>=cutOff);
        [yContour xContour zContour] = ind2sub([ys xs zs],contourIndex);
        unassignedContour = [yContour xContour zContour];
        nContours = numel(contourIndex);
        distance = zeros(nContours, nPeaks);
        hight=distance*0;
        for j=1:nPeaks
            distance(:,j) = sqrt(...
                (unassignedContour(:,1) - yPeak(j)).^2 +...
                (unassignedContour(:,2) - xPeak(j)).^2 +...
                (unassignedContour(:,3) - zPeak(j)).^2);
            hight(:,j)=thresholdMap(yPeak(j),xPeak(j),zPeak(j));
        end
        hightMx=max(hight,[],2);
        for j = 1:nPeaks
            highSc(:,j)=hight(:,j)./hightMx;
        end
            weight=1/high
        
        [dummy, peakAllegiance] = min(distance,[],2);
        for k=1:nPeaks
            peak(k).contour = unassignedContour(peakAllegiance==k,:); %#ok<AGROW>
            peak(k).contourIndex = contourIndex(peakAllegiance==k); %#ok<AGROW>
        end
        for l=1:nPeaks
            
                if ~exist('Dots','var')
                    lastEntry = 0;
                else
                    [lastEntry dummy] = size(Dots.Pos); %#ok<NASGU>
                end
                next = lastEntry+1;
                Dots.Pos(next,:) = [yPeak(l), xPeak(l),...
                    zPeak(l)];
                Dots.Vox(next).Pos = [peak(l).contour(:,1),...
                    peak(l).contour(:,2),...
                    peak(l).contour(:,3)];
                Dots.Vox(next).Ind = sub2ind([Rys Rxs Rzs],...
                    Dots.Vox(next).Pos(:,1), Dots.Vox(next).Pos(:,2),...
                    Dots.Vox(next).Pos(:,3));
                Dots.Vol(next) = numel(peak(l).contourIndex);
                Dots.ITMax(next) = thresholdPeak;
                Dots.ItSum(next) = sum(thresholdMap(peak(l).contourIndex));
                Dots.Vox(next).RawBright = Igm(peak(l).contourIndex);
                Dots.MeanBright(next) = mean(Igm(peak(l).contourIndex));
          

        end
    end
end
Dots.ImSize = [Rys Rxs Rzs];
Dots.Num = size(Dots.Pos,1); %#ok<NASGU> 
save([TPN 'Dots.mat'],'Dots')
toc       
    

